--------------------------------------------------------------------------------

环境：
  1. Atom编辑器
  2. 集成服务器环境：Windows-wamp、Linux-Nginx、Mac-xampp
  3. VMware虚拟机
  4. CentOS 64bit镜像(mirrors.163.com下载)
  5. putty、winSCP(Mac用yummy FTP、Linux直接SSH)
  6. Photoshop CS6以上版本
  7. git for windows(Mac用git-scm、Linux直接yum/apt)
  8. TortoiseSVN(Mac用SnailSVN、Linux直接yum/apt)
  9. Node.js v9.*
  10. phonegap-cli v6.5.2(不要用最新版)
  11. APICloud Studio 2
  12. Navicat for MySQL
  13. MongoDB
  14. chrome、Firefox

--------------------------------------------------------------------------------

atom
  1.优点:插件丰富
  2.缺点:打开大文件卡

  ctrl+shift+p 调出快捷菜单

--------------------------------------------------------------------------------

插件

--------------------------------------------------------------------------------

工具:
  1.版本控制
    svn-中心服务器 checkout commit          update
    git-去中心化的 clone    add/commit/push pull
      .gitignore 这个文件会分发给其他人,高层的.gitignore会被低层的.gitignore覆盖掉
      $GIT_DIR/info/exclude 将不需要分享给其他人的文件保存到这个文件夹
      ssh-keygen 生成ssh密钥

  2.书写
    markdown

    标题——#,##,###
    列表——- ,1.
    加粗——**xx**
    引用——>xx
    代码——```xx```

  3.编译、打包

    编译：ES6 -> ES5 babel
    打包：

    万能：grunt、gulp       老了
    编译：bable、browserify 单一
    同步：browser-sync      单一

    WebPack主力

--------------------------------------------------------------------------------

  全栈：前台、移动端、混合、后台、数据库、工具、部署、linux、版本、文档...

--------------------------------------------------------------------------------

课程内容：
  1. 基础知识：ES6/ES7、HTML/CSS3、数据交互...
  2. 移动端：布局、touch、库
  3. 图形：canvas、SVG/VML、Raphael、d3、echarts、WebGL...
  4. 游戏：
  5. 工具：版本控制、编译、打包...
  6. 后台：Node、express、KDA、爬虫...
  7. 混合开发
  8. 微信：公号、小程序
  9. 三大框架：angular、vue、react
  10. 数据结构、算法、设计模式

--------------------------------------------------------------------------------

基础
1. ES6

  EMCAScript(EMCA、ES)标准

  JavaScript是EMCAScript的一种

  ES6新语法
    1. 变量/赋值
      var     可以重复定义、不能限制修改、没有块级作用域只有函数级作用域
      let     不能重复定义、变量、有块级作用域
      const   不能重复定义、常量、有块级作用域

      -------------------------------------------

      解构赋值
      1. 左右两边结构必须一样
        let [a,b,c]=[1,2,3]; 是ok的
        let {a,b,c}={x:1,y:2,t:3}; 是不行的
      2. 必须定义和赋值同步完成

    2. 函数
      箭头函数 不能用arguments
        function(参数,参数){
          函数体
        }

        (参数，参数)=>{
          函数体
        }

        1. 如果有且仅有1个参数,()可以省
        2. 如果函数体只有一句话，而且是return,()可以省
        关于this,箭头函数会改变this

        -------------------------------------------

        ps：
        array.sort([compareFunction]);
        function compare(a, b) {
          if (a is less than b by some ordering criterion) {
            return -1;
          }
          if (a is greater than b by the ordering criterion) {
            return 1;
          }
          // a must be equal to b
          return 0;
        }

      -------------------------------------------

      默认参数
        function(a,b,c){
          b=b||2;
          c=c||3;
        }

        function(a,b=2,c=3){

        }

        c++的默认参数必须放在最后,这个默认参数需要放在最后么?(不需要)

      参数展开(剩余参数,数组展开)
        1. 三个点第1个作用：接收剩余参数
          function show(a,b,...args){

          }

          剩余参数必须在参数列表最后

        2. 三个点第2个作用：展开一个数组

      -----------------------------------------

    3. 数组/json

      数组——5种
        map    映射:一个对一个
          let a=[1,2,60,30,80];
          let b=a.map((item,index)=>2*item);

        filter 过滤
          let a=[1,2,60,30,80];
          let b=a.filter(item=>item%2);

        forEach 遍历 仅用于数组 不能break
          let a=[1,2,60,30,80];
          let b=0;
          a.forEach(item=>{
            b+=item;
          });

          与for(  in  ) 类似只遍历不为'undefined'的部分
          可用Array.from([array-like])将类似数组变量转变为数组

        reduce  汇总
          let a=[,2,,30,80];
          let b=a.reduce((tmp,item,index)=>{
            console.log(tmp,item,index);
            return tmp+item;
          });

          reduce 实现
          let s_reduce_f=(tmp,item,index)=>{
            console.log(tmp,item,index);
            return tmp+item;
          };
          let s_reduce=(a,f)=>{
            let tmpExist=false;
            for(let i=1;i<a.length;i++){
              if(typeof a[i] !=='undefined'){
                try{tmp}catch(e){tmpExist=false;};
                if(!tmpExist){
                  var tmp=a[i];
                  tmpExist=true;
                }else{
                  tmp=f(tmp,a[i],i);
                }
              }
            }
            return tmp;
          };
          let d=s_reduce(a,s_reduce_f);

      -------------------------------------------

      ps:
      check if variable is defined
      if(typeof myvar !== 'undefined'){

      }
      //if variable is not declared, it will be true

      check if variable is declared
      let a;
      let aExist=true;
      try{a}catch(e){aExist=false}

      -------------------------------------------

      json——2种
        1. 简写名字和值一样可以简写
        2. function可以不写

    4. 字符串
      字符串模板：变量植入、任意折行

      let json={name:"song",age:18};
      console.log(`我的名字是${json.name}年龄是${json.age}`);

      console.log(`原样
      输出`);

      startsWith()
      endsWith()

    5. 面向对象
      箭头this、bind

      传统面向对象：
        function Person(name,age){
          this.name=name;
          this.age=age;
        }

        Person.prototype.showname=function(){
          console.log(this.name);
        }

        let t=new Person('td',18);

        //继承
        function Worker(name,age,job){
          Person.call(this,name,age);
          this.job=job;
        }

        Worker.prototype=new Person();
        Worker.prototype.constructor=Worker;
        Worker.prototype.showJob(){
          console.log(`我的工作是${this.job}`);
        }

      新
        class Person{
          constructor(name,age){
            this.name=name;
            this.age=age;
          }

          showName(){
            console.log(this.name);
          }
        }

        class Worker extents Person{
          constructor(name,age,job){
            super(name,age);
            this.job=job;
          }

          showJob(){
            console.log(`我的工作是${this.job}`);
          }
        }

        新旧方法可以混写
        extens 继承方法
        super 继承属性
        新式类中可以有内部类

      this
        let p=new Person('fjk',12);
        document.onclick=p.showName;//会出错,this指向document
        传统解决：事件的影响不会超过一层
          document.onclick=function(){
            p.showName();
          }

        新:function 的bind
          document.onclick=p.showName.bind(p);

      箭头函数this
        普通函数:取决于谁调用 this总变
        箭头函数:取决于所在环境 this不变(不能通过bind来修改)
          window.onload=function(){
            ()=>{
              this; //this指window
            }
          }

    6. Promise:解决异步操作 用同步的方式来写异步
      同步——串行  简单、方便
      异步——并发  性能高、体验好

      -----------------------------------------------------------------

      //异步
      $.ajax({
        url:'/banner_data',
        success(banners){
          $.ajax({
            url:"/banner_name",
            success(banners){

            },
            error(){
              alert("数据获取失败")
            }
          })
        },
        error(){
          alert('数据获取失败');
        }
      });

      //同步  为什么这种写法属于同步?
      let banners=$.ajax({ur:'/banner_data'});
      let name=$.ajax({ur:'/banner_name'});

      -----------------------------------------------------------------

      let p=new Promise((resolve,reject)=>{
        //感觉这里头resoleve reject 就是用来接收参数的
        $.ajax({
          url:'/banner_data',
          dataType:'json',
          success:function(json){
            resolve(json);
          },
          error(err){
            reject(err);
          }
        })
      });
      p.then((json)=>{
        console.log(json);
      },(err)=>{
        alert(err);
      })

      //多个promise
      Promise.all([p1,p2,p3]).then(arr=>{
        let [a,b,c]=arr;
        console.log(arr);
      },err=>{
        alert('失败')
      });//有一个出错就错

      $,ajax是有返回值的 返回值是promis对象
      $.ajax({
        url:'/banner_data',
        dataType:'json'
      }).then(json=>{
        alert('成功');
      }，err=>{
        alert('失败');
      })

      Promise.all([
        $.ajax({url:'1.txt',dataType:'json'});
        $.ajax({url:'2.txt',dataType:'json'});
        $.ajax({url:'3.txt',dataType:'json'});
      ]).then(arr=>{
        alert('成功');
      },err=>{
        alert('失败');
      })

      1. Promise有用——解除异步操作
      2. Promise有局限性——带逻辑的异步操作麻烦

      Promise.all();     与：所有的都成功
      Promise.race();    或：只要有一个完成就行

      ---------------------------------------------------------------

      ps:
      回调 <-> 轮询
        1. 不是定义的人调用
        2. 什么时候调用不清楚

      ---------------------------------------------------------------

    7. generator-生成器
       能暂停
       function *show(){
         alert('aa');
         let a=yield 55;
         alert('bb'+a);
       }
       let gen=show();//返回的是一个generator对象(iterator对象)
       gen.next();
       setTimeout(function(){
         gen.next();
       },5000);

       yield
         1. 参数   只能传一个参数  (通过.next([])传参)
         2. 返回   return (返回对象{value: ,done: bool})

       箭头函数没生成器

       generator+promise 配合：
       1. 外来的runner辅助执行——不统一、不标准、性能低
       2. generator函数不能使用箭头函数

    ES7
    8. async/await
       await 用来检测异步操作
       async function xxx(){
         ...
         let res=await xx;
         ...
         let res2=await xx;
         ...
       }

       let 结果=await 异步操作-promise、generator、另一个async函数;

       async function show(){
         let data1=await $.ajax({url:'test1.txt',dataType:'json'});
         let data2=await $.ajax({url:'test2.txt',dataType:'json'});
         let data3=await $.ajax({url:'test3.txt',dataType:'json'});
         console.log(data1,data2,data3);
       }

       (async ()=>{
         let data1=await $.ajax({url:'test1.txt',dataType:'json'});
         let data2=await $.ajax({url:'test2.txt',dataType:'json'});
         let data3=await $.ajax({url:'test3.txt',dataType:'json'});
         //三者是串行的
         console.log(data1,data2,data3);
       })();

       await 错误处理(一步出错就出错)
       try{
         show();
       }catch(e){
         alert('有问题');
         throw new Error();
       }
       无法捕获具体哪句异常
       -------------------------------------------------------

       ps:
       如果按普通方式来写,省了编译,会不会有性能优势
       程序:
         1. 性能
         2. 维护性、可读性、工程性
         3. 健壮性
         4. 用户体验

       性能：
        1. 网络性能  大部分
        2. 执行性能  小部分

       ------------------------------------------------------
    ES6编译:
      ES6->ES5

      Node:中间层
      1. web后台(小规模)
      2. 工具
      nodejs.org
      node:语言、环境、平台
      npm:node package manager

      npm包管理
      1. 自动下载、升级
      2. 自动下载依赖包
      npm.taobao.org
      cnpm init 创建packjson

      babel:polyfill 工具
      http://babeljs.io/
      preset——预设

  ---------------------------------------------------------------

  ps:
    js支持并发webworkder

    变量提升(专业叫法：变量预解析 但let不存在变量预解析)
      js会将变量声明提到作用域最上头(不包含赋值)
      var a=12;
      function show(){
        alert(a);
        var a=5;
      }
      show();
      //undefined

      等价于
      var a;
      a=12;
      function show(){
        var a;
        alert(a);
        a=5;
      }
      show();

    closure:能够读取其他函数内部变量的函数
      1. 读取其他函数内部变量
      2. 让这些变量保存在内存中

      var name = "The Window";
      var object={
        naem:"my object";
        getNameFunc:function(){
          return function(){
            return this.name;
          }
        }
      }
      alert(object.getNameFunc()());//this指向调用的

      var name = "The Window";
      var object={
        naem:"my object";
        getNameFunc:function(){
          that=this;
          return function(){
            return that.name;
          }
        }
      }
      alert(object.getNameFunc()());//闭包

      chain scope:父对象的所有变量对子对象可见

  ---------------------------------------------------------------

2. 底层原理
  数据交互
    1. 表单      最基本最简单        http所有数据其实都是表单
    2. ajax      不用刷新页面       网慢的情况下可能存在重复提交
    3. jsonp     跨域,安全性太差    只能发起get请求
    4. WebSocket 快、双向、跨域

    ajax      性能低                   单工
    websocket 性能能高   考虑大量数据   双工    跨域

    ajax 轮询更新数据
    websocket

  跨域:
    必须情况:
      1. 网址域名改变
      2. 第三方数据

    方式:
      1. 表单
      2. ajax——麻烦、安全
      3. jsonp——简单、有风险
      4. ws

  1. http协议
    http1.0   一次性连接
    http1.1   保持连接   性能提升
    http2.0(草案)
      1. 强制https
      2. 自带双向通信
      3. 多路复用
    http      容易被攻击
    https     安全

    1. 三次握手
    2. http
      http头<=32k
      http体<=1g

  ---------------------------------------------------------------------------

  osi七层参考模型
    1. 物理层
    2. 数据链路层
    3. 网络层
    4. 传输层
    5. 会话层
    6. 表达层
    7. 应用层

  五层模型
    1. 物理层
    2. 链路层
    3. 网络层
    4. 传输层
      TCP——传输控制协议
      UDP——用户数据报协议
    5. 应用层

  ---------------------------------------------------------------------------

  2. 表单(服务器不区分表单、ajax和jsonp)
    1. 属性
      action:提交地址
      methods:方式:GET/POST/HEAD/DELETE
      name:必须加、可以重复(重复情况下服务器那边是数组)
      value:
      type:

    2. 数据提交方法
      GET    数据存在url里
        1. 容量有限
        2. 看得见(表单)
        3. 有缓存
        4. 利于分享和收藏

      POST   数据放在http-body里
        1. 容量大
        2. 看不见
        3. 无缓存
        4. 无法分享和收藏

      两种方法安全性相同

    3. 校验
      可以
      const $=function(...args){
        return document.querySelectoAll(...args);
      }
      不能
      const $=document.querySelectoAll;//这种写会导致this 指向window而不是document
      可以
      const $=document.querySelectoAll.bind(document);

    4. ajax

      if(window.XMLHttpRequest){
        var xhr=new XMLHttpRequest();  //不兼容ie6
      }else{
        var xhr=new ActiveXObject("Microsoft.XMLHttp");
      }

      //连接
      xhr.open('GET','url',true);
      //true异步——并行
      //false同步——串行 会阻塞主线程

      //发送
      xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
      xhr.send();

      //接收
      //状态
      //0初始化 1连接 2发送 3已接收(头) 4已接收
      //http状态码
      //1xx 消息
      //2xx 成功
      //3xx 重定向
      //  301 永久重定向
      //  302 临时重定向
      //  304 找缓存
      //4xx 请求错误
      //5xx 服务器错误
      //  503 服务不可用
      //6xx 可拓展
      xhr.onreadystatechange=function(){
        alert(xhr.readyState);
        if(xhr.readyState==4){
          if(xhr.status>=200 && xhr.status<=300 || xhr.status==304){
            alert('成功${xhr.responseText}');
            //xhr.responseXML
          }else{
            alert('失败');
          }
        }
      }

      post提交到后台修改content-type
        application/x-www-form-urlencoded

      ajax封装
      function ajax(options){
        //参数超过五个且不能缩减，用对象
        options=options || {};
        options.type=options.type || 'GET';
        options.data=options.data || {};
        options.datatype=options.datatype || 'text';

        let arr=[];
        for(let name in options.data){
          arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(options.data[name])}`);
        }
        let str=arr.join('&');

        let xhr;
        if(window.XMLHttpRequest){
          xhr=new window.XMLHttpRequest();
        }else{
          xhr=new ActiveXObject("Microsoft.XMLHttp");
        }
        if(options.type=='GET'){
          xhr.open(options.type,`${options.url}?${str}`,true);
          xhr.send();
        }else{
          xhr.open(options.type,options.url,true);
          xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
          xhr.send(str);
        }

        xhr.onreadystatechange=function(){
          if(xhr.readyState==4){
            if(xhr.status>=200 && xhr.status<=300 || xhr.status==304){
              let data=xhr.responseText;
              switch(options.datatype){
                case 'json':
                  if(JSON && JSON.parse){
                    data=JSON.parse(data);
                  }else{
                    data=eval('('+data+')');
                  }
                break;
                case 'xml':
                  data=xhr.responseXML;
                break;
                default:
                break;
              }
              options.success && options.success(data);
            }else{
              options.error && options.error();
            }
          }
        }
      }

      表单提交文件时需要设置enctype属性为multipart/form-data

    --------------------------------------------------------------------------

    缓存并不一定不向服务器请求

    重定向  给浏览器下命令，让浏览器请求另一个网址——地址变化
    转发    在服务器内部，把请求交给另外一个模块处理，对客户端不可见——地址不变

    --------------------------------------------------------------------------

    什么时候用表单什么时候用ajax
      1. 表单——稳定
      2. ajax——用户体验

    表单重复提交如何处理
      1. 开始提交时禁用submit
      2. 成功/失败时启用submit

    怎么删除已签名的cookie
      连带签名一起删

    单点登录oauth2

    restful 风格/习惯

    content-type:
      text/plain        纯文本
      application/x-www-form-urlencoded
      multipart/form-data 定界符分割各个数据

    urlencoded=>url 编码 名字=值&名字=值

    --------------------------------------------------------------------------

  3. 跨域
    1. jsonp(跨域)
      安全性问题-过于开放

    2. ajax cors跨域

    3. websocket

3. nodejs
  1. 原生nodeJS
    NodeJS和其他后台语言的不同
      优点
      1. nodejs的对象、语法和javaScript一模一样
      2. nodejs性能还可以80多倍  PHP、Java
      3. 前后台配合方便

      缺点
      1. Java极其丰富的库支持

    用处
      1. 服务器——小型后台系统、中间层
      2. 工具
        测试、构建(grunt、gulp、webpack...)、抓取

    运行NodeJS程序
      node xxx.js

    如何用nodejs搭建web服务器
      require //引入一个模块
      const http=require("http");
      let server=http.createServer((req,res)=>{
        //浏览器访问时的回调函数
        //req 请求数据
        //res 返回数据
        console.log("fjjd");//访问会执行两次 一次访问/ 一次访问/favicon.ico
        res.write(str);
        res.end();//必须否则浏览器不知道数据发送完了
      })
      server.listen(8080);

      //解析url
      const http=require("http");
      const fs=require("fs");
      let s=http.createServer((req,res)=>{
        fs.readFile(`.${req.url}`,(err,data)=>{
          if(err){
            console.log("出错");
            res.writeHeader(404);
            res.write('Not Found');
          }else{
            res.write(data);
          }
          res.end();  //这个res.end()因为异步操作事件循环的问题不能放在 1 位置
        });
      });
      //res.end()                                      1
      s.listen(8080);

    ---------------------------------------------------------------------------

      ps:
      NodeJS大量依靠模块
      常用端口:
        http:80
        mysql:3306

      NodeJS能处理并发么
        NodeJS和JS一样都是单线程、单进程
        非阻塞的异步交互  ???
        阻塞IO(c语言):前一个IO没完事，程序等着           同步
        非阻塞IO(JAVA,Node):前一个IO没完事，程序接着跑   异步

      NodeJS作中间层的好处
        安全性、性能(可以做一些缓存)、前台交互

      createServer 中回调函数的执行过程
        socket.on('data',function(){
          req=解析请求;
          res=socket;
          cb(req,res);
        })

      NodeJS三大特性
        单线程、非阻塞IO、事件循环

      负载均衡——架构师

      正向代理：内部网络对外部的访问
      反向代理：外部网络对内部的访问

      js深浅拷贝
        js对象赋值是引用形式
        浅拷贝：let arr1=arr2.concat([]);//一层
        深拷贝：let arr1=JSON.parse(JSON.stringify(arr2));

    ----------------------------------------------------------------------------

      ps:
      NodeJS模块:
        1. HTTP/HTTPS/ HTTP/2
        2. 断言
          const assert=require("assert");
          assert(条件,否时)
        3. Async Hooks (回调行为)
        4. 帮助处理二进制数——Buffer(文件/图片)
          File System
            const fs=require('fs')
            fs.readFile('path',(err,data)=>{
              //data为Buffer对象
              //二进制数据文件不要转为字符串
            });
            fs.writeFile('path','fdsfhdj',err=>{

            });
        5. C++ Addons (c++插件)
        6. 多进程(无法多线程)
          Child Processes
          Cluster
          Process
        7. Crypto——签名
          md5、sha
          const crypto=require("crypto");
          let obj=crypto.createHash('md5');
          obj.update("fjd");
          console.log(obj.digest('hex'));
        8. OS——操作系统信息
        9. Path——处理路径
        10.Events——事件队列
          async

          const EventEmitter = require('events');
          class MyEmitter extends EventEmitter {}
          const myEmitter = new MyEmitter();
          myEmitter.on('event', (a,b,c) => {
            console.log('an event occurred!');
          });
          myEmitter.emit('event',12,12,12);
        11. Query Strings
          const querystring=require('querystring');
          let obj=querystring.parse("a=12&b=13");
          console.log(obj);

          URL
            const url=require("url");
            let obj=url.parse("https://www.nuaakx.com/?a=12&b=13",true);
            console.log(obj);

        12. 网络
          TCP——稳定  Net
          UDP——快    UDP/Datagram
        13. 域名解析
          DNS
          const dns=require("dns");
          dns.resolve('baidu.com',(err,res)=>{
            if(err){
              console.log('解析失败');
            }else{
              console.log(res);
            }
          })
        14. 流操作
          连续数据都叫流——视频流、网络流、文件流、语音流
        15. TLS/SSL
          加密、安全(https基于SSL)
        16. ZLTB——gz
          压缩

    ----------------------------------------------------------------------------

      ps:
      怎么加密才最安全
        一次一密 密钥长度>内容长度
        目前最安全：RSA

      双层md5
        md5是单层散列，双层md5是散列后加混淆再散列

      多进程  成本高  慢  安全    通信麻烦  写代码简单
      多线程  成本低  快  不安全  通信简单  写代码复杂

      require:http://www.ruanyifeng.com/blog/2015/05/require.html
        任何一个js文件都是一个moudle,在被require时都会执行
        require 不是全局命令而是每个模块内部提供的方法

      程序员
        1. 算法
        2. 设计模式
        3. 架构

      网站被运营商劫持可以用https加密

      进程通信
        1. 管道
        2. 共享内存
        3. socket

      前端把加密数据传到后台，后台怎么校验
        签名

      加密算法
        RSA

      Web服务器:
        1. 返回文件
        2. 数据交互(get/post)
        3. 数据库

      一个大数据包为啥切成一堆小包
        1. 方便所有人
        2. 容错强

      on监听是轮询么
        不是，是监听/通知/回调/异步

      安全性:99%的漏洞都是懒
        1. 一切来自前台的数据都是不可靠的
        2. 前后台都要进行数据校验
          前台校验：用户体验
          后台校验：安全性

      为什么http://localhost/../index.php 无法访问

      在localhost的网站ajax访问localhost:8080的网址在networks中能看到请求和返回的结果
      但是浏览器提示跨域并且无法显示结果,所以同一服务器的不同端口也算跨域

    ----------------------------------------------------------------------------

    Nodejs数据交互
      //处理post数据
      const http=require("http");
      const querystring=require("querystring");

      let server=http.createServer((req,res)=>{
        let str='';  //这种方式在处理文件时是有缺陷的
        req.on('data',data=>{
          str+=data;
        });
        req.on('end',()=>{
          let post=querystring.parse(str);
          console.log(post);
          res.write(str);
          res.end();
        });
      });
      server.listen(8080);

      //处理post和get
      const http=require('http');
      const url=require('url');
      const querystring=require('querystring');
      let server=http.createServer((req,res)=>{
        let {query:get,pathname}=url.parse(req.url,true);
        let str='';
        req.on('data',data=>{
          str+=data;
        });
        req.on('end',()=>{
          let post=querystring.parse(str);
          console.log(get,post);
          res.end();
        });
      });
      server.listen(8080);

      url.parse('')//解析url
      querystring.parse('')//解析数据

    接口
      定下来——接口文档
      写下来

      注册/登录
      const http=require('http');
      const url=require('url');
      const querystring=require('querystring');
      const fs=require('fs');
      let users={
        //"user":"passwd"
      }
      let server=http.createServer((req,res)=>{
        let {query:get,pathname}=url.parse(req.url,true);
        let str='';
        req.on('data',data=>{
          str+=data;
        });
        req.on('end',()=>{
          let post=querystring.parse(str);
          console.log(get,post);
          switch(pathname){
            case '/reg':
              if(!get["user"]){
                res.write(`{"error":1,"msg":"username is needed"}`);
              }else if(!get["passwd"]){
                res.write(`{"error":1,"msg":"passwd is needed"}`);
              }else if(/[^a-z]{8,18}$/.test(get["user"])){
                res.write(`{"error":1,"msg":"invalid username"}`);
              }else if(/[\'\"]+/.test(get["passwd"])){
                res.write(`{"error":1,"msg":"invalid passwd"}`);
              }else if(users[get["user"]]){
                res.write(`{"error":1,"msg":"user has been registed"}`);
              }else{
                users[get["user"]]=get["passwd"];
                res.write(`{"error":0,"msg":"successed"}`);
              }
              res.end();
              break;
            case '/login':
              if(!get["user"]){
                res.write(`{"error":1,"msg":"username is needed"}`);
              }else if(!get["passwd"]){
                res.write(`{"error":1,"msg":"passwd is needed"}`);
              }else if(/[^a-z]{8,18}$/.test(get["user"])){
                res.write(`{"error":1,"msg":"invalid user"}`);
              }else if(/[\'\"]+/.test(get["passwd"])){
                res.write(`{"error":1,"msg":"invalid passwd"}`);
              }else if(!users[get["user"]] || get["passwd"]!=users[get["user"]]){
                res.write(`{"error":1,"msg":"user or passwd is wrong"}`);
              }else{
                res.write(`{"error":0,"msg":"successed"}`);
              }
              res.end();
              break;
            default:
              fs.readFile(`../${pathname}`,(err,data)=>{
                if(err){
                  res.writeHeader(404);
                }else{
                  res.write(data);
                }
                res.end();
              });
              break;
          }
        });
      });
      server.listen(8080);

    数据库
      1. 文件型数据库——sqlite
        简单、不庞大
      2. 关系型数据库——MySQL Oracle     最常见最常用
        数据之间是有关系的 数据结构是固定的
      3. 文档型数据库——MongDB
        直接存储异构数据——方便
      大型系统的主数据库——关系型
      MySQL  80%   免费   绝大多数普通应用
        性能高、安全性高
        容灾性差
      Oracle       要钱
        容灾性强

      SQL     性能差
      NoSQL   没有复杂的关系、对性能有很高的要求
        redis        在内存中 可以做负载平衡
        memcached
        hypertable
        bigtable

      数据仓库——海量数据

    ---------------------------------------------------------------------------

      磁盘增量镜像

      Node缓存
        第一次
          服务器->浏览器
            cache-control
            expires
            date
        第二次
          浏览器->服务器
            get
            date
          服务器->浏览器(服务器将文件最后修改日期跟date比)
            304(无内容)/200(有内容)

      Node/JavaScript的垃圾回收 gc
        1. 只要某个东西不再使用，释放掉所占据的内存
        通过引用的计数，引用数为0时可以回收

      重新发布数据后浏览器需要ctrl+r强制获取最新资源，如何做到通过F5刷新即可获取资源
        1. 后台配置(把缓存禁了)
        2. <script src="server.js?t=v1"></script>

      服务器缓冲池
        1. 最近最长使用的资源留在内存中(根据实际访问情况来定)

      websocket长连接会不会影响性能
        比新建立连接要好

      表单的三种post
        1. text/plain                                纯文本
        2. application/x-www-form-urlencoded         url编码格式
        3. multipart/form-data                       上传文件内容(切块)

      http协议换行
        \r\n

    ---------------------------------------------------------------------------

    解析数据:
      ------WebKitFormBoundarydASqAKbzA8knhLC2
      Content-Disposition: form-data; name="a"

      fjlds
      ------WebKitFormBoundarydASqAKbzA8knhLC2
      Content-Disposition: form-data; name="b"

      fjksd
      ------WebKitFormBoundarydASqAKbzA8knhLC2
      Content-Disposition: form-data; name="file"; filename="file.txt"
      Content-Type: text/plain

      jfsldk
      jfldks


      jflksd

      ------WebKitFormBoundarydASqAKbzA8knhLC2--

      <分隔符>\r\n
      数据描述\r\n\r\n数据内容\r\n
      <分隔符>\r\n
      数据描述\r\n\r\n数据内容\r\n
      <分隔符>\r\n
      数据描述1\r\n数据描述2\r\n\r\n数据内容\r\n
      <分隔符>--\r\n

      1. 用分隔符分割数据
        [,
        \r\n数据描述\r\n\r\n数据内容\r\n,
        \r\n数据描述\r\n\r\n数据内容\r\n,
        \r\n数据描述1\r\n数据描述2\r\n\r\n数据内容\r\n,
        --\r\n]
      2. 丢弃头尾数据
        [\r\n数据描述\r\n\r\n数据内容\r\n,
        \r\n数据描述\r\n\r\n数据内容\r\n,
        \r\n数据描述1\r\n数据描述2\r\n\r\n数据内容\r\n]
      3. 丢弃每一项头尾\r\n
        [数据描述\r\n\r\n数据内容,
        数据描述\r\n\r\n数据内容,
        数据描述1\r\n数据描述2\r\n\r\n数据内容]
      4. 用第一次出现的\r\n\r\n切分
        普通数据:[数据描述,数据值]
        或
        文件数据:[数据描述1\r\n数据描述2,文件内容]
      5. 判断描述里面有没有\r\n
        有   文件数据
        没有 普通数据
      6. 分析数据描述

      const http=require('http');
      const split=require('./split.js');
      const url=require('url');
      const fs=require('fs');
      const uuid=require('uuid/v4');

      let server=http.createServer((req,res)=>{
        let result=[];
        let {pathname,query}=url.parse(req.url,true);
        req.on('data',data=>{
          result.push(data);
        });
        req.on('end',()=>{
          let buf=Buffer.concat(result);
          let arr=[];
          let content_type;
          let boundary;
          if(req.headers["content-type"]){
            [content_type,boundary]=req.headers["content-type"].split(";");
            if(boundary){
              boundary="--"+boundary.split("=")[1];
            }
          }
          let post={};  //存储解析结果
          switch(pathname){
            case '/upload':
              if(boundary){
                //1. 用boundary分割
                arr=buf.split(boundary);

                //2. 删除头尾
                arr.shift();
                arr.pop();

                //3. 丢弃每项头尾\r\n
                arr=arr.map(data=>{
                  return data.slice(2,data.length-2);
                });

                //4. 用第一次出现的\r\n\r\n切分
                arr.forEach(buffer=>{
                  let first=buffer.indexOf('\r\n\r\n');

                  let disposition=buffer.slice(0,first);
                  let content=buffer.slice(first+4);

                  if(disposition.indexOf('\r\n')!=-1){
                    let [line1,line2]=disposition.split('\r\n');
                    let s=line1.split(';');
                    let name=s[1].split('\"')[1];
                    let filename=s[2].split('\"')[1];
                    filename=uuid().replace(/\-/g,'')+filename.toString().match(/\.[a-zA-Z]+$/)[0];
                    fs.writeFile('upload/'+filename,content,err=>{
                      if(err){
                        console.log('写入失败');
                        console.log(err);
                      }else{
                        console.log('写入成功');
                      }
                    });
                    post[name.toString()]={"filename":filename.toString(),"content":content};

                  }else{
                    let name=disposition.split(';')[1].split('\"')[1];
                    post[name.toString()]=content.toString();
                  }
                });
              }
              break;
            default:
              break;
          }
          res.end();
        });
      })
      server.listen(8080);

      问题:
        1. 错误:会等到所有数据到达后才开始处理
           正确:收到一部分解析一部分             节约内存
        2. fs.readFile()            将文件读完后才会执行回掉函数
             1. 及其占用内存
             2. 资源利用不充分
           fs.writeFile()

    Buffer数据处理
      1. 查找 indexOf()
      2. 截取 slice()
      3. 分割
      Buffer.prototype.split=Buffer.prototype.split||function (str){
        let [cur,n]=[0,0];
        let result=[];
        while(cur<this.length){
          n=this.indexOf(str,cur);
          if(n!=-1){
            result.push(this.slice(cur,n));
            cur=n+str.length;
          }else{
            result.push(this.slice(cur));
            break;
          }
        }
        return result;
      }

    ----------------------------------------------------------------------------

      npm install -D
      -D工程依赖

    ----------------------------------------------------------------------------

    uuid guid
      const uuid=require('uuid/v4');
      console.log(uuid().replace(/\-/g,''));

    流:
      读一点 发一点
      1. 读取流     fs.createrReadStream();
      2. 写入流     fs.createrWriteStream();
      3. 读写流     压缩、加密
      const fs=require('fs');
      const zlib=require('zlib');
      let rs=fs.createReadStream('1.js');
      let ws=fs.createWriteStream('2.js.gz');
      let gz=zlib.createGzip();
      rs.pipe(gz).pipe(ws);

    基于流的服务器
      const http=require('http');
      const fs=require('fs');
      const zlib=require('zlib');

      let server=http.createServer((req,res)=>{
        let rs=fs.createReadStream(`..${req.url}`);
        let gz=zlib.createGzip();
        res.setHeader('Content-Encoding','gzip');
        rs.pipe(gz).pipe(res);
        rs.on('error',err=>{
          console.log('文件读取失败');
          console.log(err);
          res.writeHeader(404);
          res.end();
        });
        rs.on('finish',()=>{
          console.log('文件读写完毕');
          res.write('haha');
          res.end();
        })
      });
      server.listen(8080);

      这里面的rs.on('finish')好像没触发，为什么呢?
      res.setHeader()和res.writeHeader()有什么不同呢?
        writeHeader()是用来写状态的
        setHeader()是用来写request header的

    ----------------------------------------------------------------------------

    流的底层原理还是不是readfile?
      生产者/消费者模型

    面向字节的设备    ->     键盘     一个字一个字处理
    面向流的设备      ->     网卡     一块一块处理

    post提交时如果xhr.send(xxx) 参数内容是{a:'12',b:{c:3}}应该如何解决
      1. 直接发json
        content-type: application/json
        {"a":"12","b":{"c":3}}
      2. 变相
        content-type: urlencoded
        data="%7B%22a%22%3A%2212%22%2C%22b%22%3A%7B%22c%22%3A3%7D%7D"
        encodeURIComponent();
        decodeURIComponent();

    content-range  断点续传

    服务端怎么判断文件类型
      1. 为什么要判断      没必要
      2. 简单:文件拓展名
         复杂:分析文件结构

    ----------------------------------------------------------------------------

    缓存:
      第一重要 缓存策略
        cache-control
        expires

      第二重要 缓存实现过程
        1. 第一次s->c:Last-Modified: Sun, 13 Jan 2019 06:56:13 GMT
        2. 第二次c->s:If-Modified-Since: Sun, 13 Jan 2019 06:56:13 GMT
        3. 第二次s->c:304
      const http=require('http');
      const fs=require('fs');
      const url=require('url');
      const zlib=require('zlib');

      let server=http.createServer((req,res)=>{
        let {pathname}=url.parse(req.url,true);
        pathname=`..${pathname}`;
        fs.stat(pathname,(err,state)=>{
          if(err){
            res.writeHeader(404);
            res.end();
          }else{
            let gz=zlib.createGzip();
            let rs=fs.createReadStream(pathname);
            res.setHeader('content-encoding','gzip');
            console.log(req.headers);
            if(req.headers['if-modified-since']){
              let t=new Date(req.headers['if-modified-since']);
              let ct=t.getTime()/1000;
              let st=Math.floor(state.mtime.getTime()/1000);
              console.log(ct,st);
              if(ct<st){
                //更新本地缓存
                //这里Math.floor是很有必要的
                update();
              }else{
                res.writeHeader(304);
                res.end();
              }
            }else{
              update();
            }
            function update(){
              res.setHeader('last-modified',state.mtime.toGMTString());
              rs.pipe(gz).pipe(res);
              rs.on('error',err=>{
                console.log(err);
                res.writeHeader(404);
                res.end();
              });
            }
          }
        });
      });
      server.listen(8080);

    ----------------------------------------------------------------------------

    多进程:性能略低;简单、对程序员要求低
    多线程:性能高;复杂、对程序员要求高

    Node.js 默认：单进程、单线程
    主进程：负责派生子进程
    子进程：干活

    localStorage:大5m   本地存储、替代cookie
    cookie:4k

    多进程更安全 充分利用cpu
    进程：
      1. 普通程序不能创建进程，只有系统进程才能创建进程
      2. 进程是分裂出来的，只有主进程才能分裂
      3. 分裂出来的两个进程执行同一套代码
      4. 父子进程之间可以共享"句柄"   端口也算一个句柄

    主进程=守护进程
    子进程=工作进程

    进程调度——开销

    多个进程
      第一个进程满了->开第二个进程->前两个满了->开第三个进程

    进程回收pid会被回收利用

    多个进程干不同活时需要自己来控制

    ----------------------------------------------------------------------------

    多进程:
      const cluster=require('cluster');
      const http=require('http');
      const os=require('os');
      let cpu=new os.cpus();
      if(cluster.isMaster){
        for(let i=0;i<cpu.length;i++){
          cluster.fork();
        }
      }else{
        console.log(`当前进程pid${process.pid}`);
        let server=http.createServer((req,res)=>{
          res.setHeader('content-type','text/javascript;charset=UTF-8');
          res.write(`工作进程是${process.pid}`);
          res.end();
        });
        server.listen(8080);
      }

    ----------------------------------------------------------------------------

    数据库:
      1. 服务端:wamp里面的mysql、单装的MySQL的server
      2. 客户端:Node.js、Java、PHP、Navicat for MySQL

    认识数据库:
      1. 库-文件夹：不能存数据，只能管理表
      2. 表-文件：存数据

    ----------------------------------------------------------------------------

    数据库:
      MySQL:

    使用navicat
      1. 连接服务器
      2. 打开连接
      3. 新建库
        名字:尽量别用-
        字符集:uft-8
        排序规则:utf8_general_ci
      4. 新建表
        字段(列/域):项目
        行:一条数据

        字段类型:
          数字
            整数:tinyint(8位)、smallint(16位)、mediumint(24位)、int(32位)、bigint(64位)
                -128~127
            小数:float、double
          字符串
            小:varchar   255
            大:text      1g

        主键
          1. 性能高
          2. 唯一
      导入文件需要先建库

    ----------------------------------------------------------------------------

    ps:
    触发器怎么使用
      1. 事件

    表情和图片不会直接存入数据库

    utf-8存储单元是字节
    utf-16存储单元是双字节

    varchar 6 并不代表6个字节 可存6个字(多字节处理)

    下载解析渲染绘制
      1. 下载-数据加载
      2. 渲染=绘制
      渲染-慢
        1. 页面东西多
        2. 图片
        3. DOM操作
          display为none时不会影响
          也可以先拷贝再操作后替换

    const cluster=require('cluster');
    const os=require('os');
    let cpu=new os.cpus();
    console.log(process.pid);
    if(cluster.isMaster){
      for(let i=0;i<cpu.length;i++){
        cluster.fork();
      }
    }
    这段程序执行完后还会挂起的原因是主进程要等待子进程结束
    那为什么子进程不结束呢？子进程在什么情况下会结束呢？

    缓存策略
      1. url变了不缓存
      2. 标准-每次都要请求服务器
      3. 服务器配置
      chrome在新的标签页输入已缓存的地址时会直接先从缓存中拿数据
      Status Code: 200 OK (from disk cache)

    ----------------------------------------------------------------------------

    Node使用数据库
      1. 连接
        const mysql=require('mysql');
        let db=mysql.createConnection({host:'localhost',user:'root',password:'123qazzxc',port:3306,database:'user_data'});
        let db=mysql.createPool({host:'localhost',user:'root',password:'123qazzxc',port:3306,database:'user_data',connectionLimit:10});
          connectionLimit默认值就是10
      2. 查询
        db.query('',(err,data)=>{})

    SQL
      4大查询
        1. 增  INSERT
          INSERET INTO 表 (字段列表) VALUES (值列表)
        2. 删 DELETE
          DELETE FROM 表 WHERE 条件
        3. 改 UPDATE
          UPDATE 表 SET 字段=值,字段2=值2 WHERE 条件
        4. 查 SELECT
          SELECT 字段,字段 FROM 表 WHERE 条件

    ----------------------------------------------------------------------------

    ps:
    自增id删除一条后不会回收利用

    删除项的几种方式
      1. 逻辑删除
      2. DELETE
      3. 将删除项移到另外一个库(不存在添加字段)

    ----------------------------------------------------------------------------




--------------------------------------------------------------------------------
