--------------------------------------------------------------------------------

环境：
  1. Atom编辑器
  2. 集成服务器环境：Windows-wamp、Linux-Nginx、Mac-xampp
  3. VMware虚拟机
  4. CentOS 64bit镜像(mirrors.163.com下载)
  5. putty、winSCP(Mac用yummy FTP、Linux直接SSH)
  6. Photoshop CS6以上版本
  7. git for windows(Mac用git-scm、Linux直接yum/apt)
  8. TortoiseSVN(Mac用SnailSVN、Linux直接yum/apt)
  9. Node.js v9.*
  10. phonegap-cli v6.5.2(不要用最新版)
  11. APICloud Studio 2
  12. Navicat for MySQL
  13. MongoDB
  14. chrome、Firefox

--------------------------------------------------------------------------------

atom
  1.优点:插件丰富
  2.缺点:打开大文件卡

  ctrl+shift+p 调出快捷菜单

--------------------------------------------------------------------------------

插件

--------------------------------------------------------------------------------

工具:
  1.版本控制
    svn-中心服务器 checkout commit          update
    git-去中心化的 clone    add/commit/push pull
      .gitignore 这个文件会分发给其他人,高层的.gitignore会被低层的.gitignore覆盖掉
      $GIT_DIR/info/exclude 将不需要分享给其他人的文件保存到这个文件夹
      ssh-keygen 生成ssh密钥

  2.书写
    markdown

    标题——#,##,###
    列表——- ,1.
    加粗——**xx**
    引用——>xx
    代码——```xx```

  3.编译、打包

    编译：ES6 -> ES5 babel
    打包：

    万能：grunt、gulp       老了
    编译：bable、browserify 单一
    同步：browser-sync      单一

    WebPack主力

--------------------------------------------------------------------------------

  全栈：前台、移动端、混合、后台、数据库、工具、部署、linux、版本、文档...

--------------------------------------------------------------------------------

课程内容：
  1. 基础知识：ES6/ES7、HTML/CSS3、数据交互...
  2. 移动端：布局、touch、库
  3. 图形：canvas、SVG/VML、Raphael、d3、echarts、WebGL...
  4. 游戏：
  5. 工具：版本控制、编译、打包...
  6. 后台：Node、express、KDA、爬虫...
  7. 混合开发
  8. 微信：公号、小程序
  9. 三大框架：angular、vue、react
  10. 数据结构、算法、设计模式

--------------------------------------------------------------------------------

基础
1. ES6

  EMCAScript(EMCA、ES)标准

  JavaScript是EMCAScript的一种

  ES6新语法
    1. 变量/赋值
      var     可以重复定义、不能限制修改、没有块级作用域只有函数级作用域
      let     不能重复定义、变量、有块级作用域
      const   不能重复定义、常量、有块级作用域

      -------------------------------------------

      解构赋值
      1. 左右两边结构必须一样
        let [a,b,c]=[1,2,3]; 是ok的
        let {a,b,c}={x:1,y:2,t:3}; 是不行的
      2. 必须定义和赋值同步完成

    2. 函数
      箭头函数 不能用arguments
        function(参数,参数){
          函数体
        }

        (参数，参数)=>{
          函数体
        }

        1. 如果有且仅有1个参数,()可以省
        2. 如果函数体只有一句话，而且是return,()可以省
        关于this,箭头函数会改变this

        -------------------------------------------

        ps：
        array.sort([compareFunction]);
        function compare(a, b) {
          if (a is less than b by some ordering criterion) {
            return -1;
          }
          if (a is greater than b by the ordering criterion) {
            return 1;
          }
          // a must be equal to b
          return 0;
        }

      -------------------------------------------

      默认参数
        function(a,b,c){
          b=b||2;
          c=c||3;
        }

        function(a,b=2,c=3){

        }

        c++的默认参数必须放在最后,这个默认参数需要放在最后么?(不需要)

      参数展开(剩余参数,数组展开)
        1. 三个点第1个作用：接收剩余参数
          function show(a,b,...args){

          }

          剩余参数必须在参数列表最后

        2. 三个点第2个作用：展开一个数组

      -----------------------------------------

    3. 数组/json

      数组——5种
        map    映射:一个对一个
          let a=[1,2,60,30,80];
          let b=a.map((item,index)=>2*item);

        filter 过滤
          let a=[1,2,60,30,80];
          let b=a.filter(item=>item%2);

        forEach 遍历 仅用于数组 不能break
          let a=[1,2,60,30,80];
          let b=0;
          a.forEach(item=>{
            b+=item;
          });

          与for(  in  ) 类似只遍历不为'undefined'的部分
          可用Array.from([array-like])将类似数组变量转变为数组

        reduce  汇总
          let a=[,2,,30,80];
          let b=a.reduce((tmp,item,index)=>{
            console.log(tmp,item,index);
            return tmp+item;
          });

          reduce 实现
          let s_reduce_f=(tmp,item,index)=>{
            console.log(tmp,item,index);
            return tmp+item;
          };
          let s_reduce=(a,f)=>{
            let tmpExist=false;
            for(let i=1;i<a.length;i++){
              if(typeof a[i] !=='undefined'){
                try{tmp}catch(e){tmpExist=false;};
                if(!tmpExist){
                  var tmp=a[i];
                  tmpExist=true;
                }else{
                  tmp=f(tmp,a[i],i);
                }
              }
            }
            return tmp;
          };
          let d=s_reduce(a,s_reduce_f);

      -------------------------------------------

      ps:
      check if variable is defined
      if(typeof myvar !== 'undefined'){

      }
      //if variable is not declared, it will be true

      check if variable is declared
      let a;
      let aExist=true;
      try{a}catch(e){aExist=false}

      -------------------------------------------

      json——2种
        1. 简写名字和值一样可以简写
        2. function可以不写

    4. 字符串
      字符串模板：变量植入、任意折行

      let json={name:"song",age:18};
      console.log(`我的名字是${json.name}年龄是${json.age}`);

      console.log(`原样
      输出`);

      startsWith()
      endsWith()

    5. 面向对象
      箭头this、bind

      传统面向对象：
        function Person(name,age){
          this.name=name;
          this.age=age;
        }

        Person.prototype.showname=function(){
          console.log(this.name);
        }

        let t=new Person('td',18);

        //继承
        function Worker(name,age,job){
          Person.call(this,name,age);
          this.job=job;
        }

        Worker.prototype=new Person();
        Worker.prototype.constructor=Worker;
        Worker.prototype.showJob(){
          console.log(`我的工作是${this.job}`);
        }

      新
        class Person{
          constructor(name,age){
            this.name=name;
            this.age=age;
          }

          showName(){
            console.log(this.name);
          }
        }

        class Worker extents Person{
          constructor(name,age,job){
            super(name,age);
            this.job=job;
          }

          showJob(){
            console.log(`我的工作是${this.job}`);
          }
        }

        新旧方法可以混写
        extens 继承方法
        super 继承属性
        新式类中可以有内部类

      this
        let p=new Person('fjk',12);
        document.onclick=p.showName;//会出错,this指向document
        传统解决：事件的影响不会超过一层
          document.onclick=function(){
            p.showName();
          }

        新:function 的bind
          document.onclick=p.showName.bind(p);

      箭头函数this
        普通函数:取决于谁调用 this总变
        箭头函数:取决于所在环境 this不变(不能通过bind来修改)
          window.onload=function(){
            ()=>{
              this; //this指window
            }
          }

    6. Promise:解决异步操作 用同步的方式来写异步
      同步——串行  简单、方便
      异步——并发  性能高、体验好

      -----------------------------------------------------------------

      //异步
      $.ajax({
        url:'/banner_data',
        success(banners){
          $.ajax({
            url:"/banner_name",
            success(banners){

            },
            error(){
              alert("数据获取失败")
            }
          })
        },
        error(){
          alert('数据获取失败');
        }
      });

      //同步  为什么这种写法属于同步?
      let banners=$.ajax({ur:'/banner_data'});
      let name=$.ajax({ur:'/banner_name'});

      -----------------------------------------------------------------

      let p=new Promise((resolve,reject)=>{
        //感觉这里头resoleve reject 就是用来接收参数的
        $.ajax({
          url:'/banner_data',
          dataType:'json',
          success:function(json){
            resolve(json);
          },
          error(err){
            reject(err);
          }
        })
      });
      p.then((json)=>{
        console.log(json);
      },(err)=>{
        alert(err);
      })

      //多个promise
      Promise.all([p1,p2,p3]).then(arr=>{
        let [a,b,c]=arr;
        console.log(arr);
      },err=>{
        alert('失败')
      });//有一个出错就错

      $,ajax是有返回值的 返回值是promis对象
      $.ajax({
        url:'/banner_data',
        dataType:'json'
      }).then(json=>{
        alert('成功');
      }，err=>{
        alert('失败');
      })

      Promise.all([
        $.ajax({url:'1.txt',dataType:'json'});
        $.ajax({url:'2.txt',dataType:'json'});
        $.ajax({url:'3.txt',dataType:'json'});
      ]).then(arr=>{
        alert('成功');
      },err=>{
        alert('失败');
      })

      1. Promise有用——解除异步操作
      2. Promise有局限性——带逻辑的异步操作麻烦

      Promise.all();     与：所有的都成功
      Promise.race();    或：只要有一个完成就行

      ---------------------------------------------------------------

      ps:
      回调 <-> 轮询
        1. 不是定义的人调用
        2. 什么时候调用不清楚

      ---------------------------------------------------------------

    7. generator-生成器
       能暂停
       function *show(){
         alert('aa');
         let a=yield 55;
         alert('bb'+a);
       }
       let gen=show();//返回的是一个generator对象(iterator对象)
       gen.next();
       setTimeout(function(){
         gen.next();
       },5000);

       yield
         1. 参数   只能传一个参数  (通过.next([])传参)
         2. 返回   return (返回对象{value: ,done: bool})

       箭头函数没生成器

       generator+promise 配合：
       1. 外来的runner辅助执行——不统一、不标准、性能低
       2. generator函数不能使用箭头函数

    ES7
    8. async/await
       await 用来检测异步操作
       async function xxx(){
         ...
         let res=await xx;
         ...
         let res2=await xx;
         ...
       }

       let 结果=await 异步操作-promise、generator、另一个async函数;

       async function show(){
         let data1=await $.ajax({url:'test1.txt',dataType:'json'});
         let data2=await $.ajax({url:'test2.txt',dataType:'json'});
         let data3=await $.ajax({url:'test3.txt',dataType:'json'});
         console.log(data1,data2,data3);
       }

       (async ()=>{
         let data1=await $.ajax({url:'test1.txt',dataType:'json'});
         let data2=await $.ajax({url:'test2.txt',dataType:'json'});
         let data3=await $.ajax({url:'test3.txt',dataType:'json'});
         //三者是串行的
         console.log(data1,data2,data3);
       })();

       await 错误处理(一步出错就出错)
       try{
         show();
       }catch(e){
         alert('有问题');
         throw new Error();
       }
       无法捕获具体哪句异常
       -------------------------------------------------------

       ps:
       如果按普通方式来写,省了编译,会不会有性能优势
       程序:
         1. 性能
         2. 维护性、可读性、工程性
         3. 健壮性
         4. 用户体验

       性能：
        1. 网络性能  大部分
        2. 执行性能  小部分

       ------------------------------------------------------
    ES6编译:
      ES6->ES5

      Node:中间层
      1. web后台(小规模)
      2. 工具
      nodejs.org
      node:语言、环境、平台
      npm:node package manager

      npm包管理
      1. 自动下载、升级
      2. 自动下载依赖包
      npm.taobao.org
      cnpm init 创建packjson

      babel:polyfill 工具
      http://babeljs.io/
      preset——预设

  ---------------------------------------------------------------

  ps:
    js支持并发webworkder

    变量提升(专业叫法：变量预解析 但let不存在变量预解析)
      js会将变量声明提到作用域最上头(不包含赋值)
      var a=12;
      function show(){
        alert(a);
        var a=5;
      }
      show();
      //undefined

      等价于
      var a;
      a=12;
      function show(){
        var a;
        alert(a);
        a=5;
      }
      show();

    closure:能够读取其他函数内部变量的函数
      1. 读取其他函数内部变量
      2. 让这些变量保存在内存中

      var name = "The Window";
      var object={
        naem:"my object";
        getNameFunc:function(){
          return function(){
            return this.name;
          }
        }
      }
      alert(object.getNameFunc()());//this指向调用的

      var name = "The Window";
      var object={
        naem:"my object";
        getNameFunc:function(){
          that=this;
          return function(){
            return that.name;
          }
        }
      }
      alert(object.getNameFunc()());//闭包

      chain scope:父对象的所有变量对子对象可见

  ---------------------------------------------------------------

2. 底层原理
  数据交互
    1. 表单      最基本最简单        http所有数据其实都是表单
    2. ajax      不用刷新页面       网慢的情况下可能存在重复提交
    3. jsonp     跨域,安全性太差    只能发起get请求
    4. WebSocket 快、双向、跨域

    ajax      性能低                   单工
    websocket 性能能高   考虑大量数据   双工    跨域

    ajax 轮询更新数据
    websocket

  跨域:
    必须情况:
      1. 网址域名改变
      2. 第三方数据

    方式:
      1. 表单
      2. ajax——麻烦、安全
      3. jsonp——简单、有风险
      4. ws

  1. http协议
    http1.0   一次性连接
    http1.1   保持连接   性能提升
    http2.0(草案)
      1. 强制https
      2. 自带双向通信
      3. 多路复用
    http      容易被攻击
    https     安全

    1. 三次握手
    2. http
      http头<=32k
      http体<=1g

  ---------------------------------------------------------------------------

  osi七层参考模型
    1. 物理层
    2. 数据链路层
    3. 网络层
    4. 传输层
    5. 会话层
    6. 表达层
    7. 应用层

  五层模型
    1. 物理层
    2. 链路层
    3. 网络层
    4. 传输层
      TCP——传输控制协议
      UDP——用户数据报协议
    5. 应用层

  ---------------------------------------------------------------------------

  2. 表单(服务器不区分表单、ajax和jsonp)
    1. 属性
      action:提交地址
      methods:方式:GET/POST/HEAD/DELETE
      name:必须加、可以重复(重复情况下服务器那边是数组)
      value:
      type:

    2. 数据提交方法
      GET    数据存在url里
        1. 容量有限
        2. 看得见(表单)
        3. 有缓存
        4. 利于分享和收藏

      POST   数据放在http-body里
        1. 容量大
        2. 看不见
        3. 无缓存
        4. 无法分享和收藏

      两种方法安全性相同

    3. 校验
      可以
      const $=function(...args){
        return document.querySelectoAll(...args);
      }
      不能
      const $=document.querySelectoAll;//这种写会导致this 指向window而不是document
      可以
      const $=document.querySelectoAll.bind(document);

    4. ajax

      if(window.XMLHttpRequest){
        var xhr=new XMLHttpRequest();  //不兼容ie6
      }else{
        var xhr=new ActiveXObject("Microsoft.XMLHttp");
      }

      //连接
      xhr.open('GET','url',true);
      //true异步——并行
      //false同步——串行 会阻塞主线程

      //发送
      xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
      xhr.send();

      //接收
      //状态
      //0初始化 1连接 2发送 3已接收(头) 4已接收
      //http状态码
      //1xx 消息
      //2xx 成功
      //3xx 重定向
      //  301 永久重定向
      //  302 临时重定向
      //  304 找缓存
      //4xx 请求错误
      //5xx 服务器错误
      //  503 服务不可用
      //6xx 可拓展
      xhr.onreadystatechange=function(){
        alert(xhr.readyState);
        if(xhr.readyState==4){
          if(xhr.status>=200 && xhr.status<=300 || xhr.status==304){
            alert('成功${xhr.responseText}');
            //xhr.responseXML
          }else{
            alert('失败');
          }
        }
      }

      post提交到后台修改content-type
        application/x-www-form-urlencoded

      ajax封装
      function ajax(options){
        //参数超过五个且不能缩减，用对象
        options=options || {};
        options.type=options.type || 'GET';
        options.data=options.data || {};
        options.datatype=options.datatype || 'text';

        let arr=[];
        for(let name in options.data){
          arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(options.data[name])}`);
        }
        let str=arr.join('&');

        let xhr;
        if(window.XMLHttpRequest){
          xhr=new window.XMLHttpRequest();
        }else{
          xhr=new ActiveXObject("Microsoft.XMLHttp");
        }
        if(options.type=='GET'){
          xhr.open(options.type,`${options.url}?${str}`,true);
          xhr.send();
        }else{
          xhr.open(options.type,options.url,true);
          xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
          xhr.send(str);
        }

        xhr.onreadystatechange=function(){
          if(xhr.readyState==4){
            if(xhr.status>=200 && xhr.status<=300 || xhr.status==304){
              let data=xhr.responseText;
              switch(options.datatype){
                case 'json':
                  if(JSON && JSON.parse){
                    data=JSON.parse(data);
                  }else{
                    data=eval('('+data+')');
                  }
                break;
                case 'xml':
                  data=xhr.responseXML;
                break;
                default:
                break;
              }
              options.success && options.success(data);
            }else{
              options.error && options.error();
            }
          }
        }
      }

      表单提交文件时需要设置enctype属性为multipart/form-data

    --------------------------------------------------------------------------

    缓存并不一定不向服务器请求

    重定向  给浏览器下命令，让浏览器请求另一个网址——地址变化
    转发    在服务器内部，把请求交给另外一个模块处理，对客户端不可见——地址不变

    --------------------------------------------------------------------------

    什么时候用表单什么时候用ajax
      1. 表单——稳定
      2. ajax——用户体验

    表单重复提交如何处理
      1. 开始提交时禁用submit
      2. 成功/失败时启用submit

    怎么删除已签名的cookie
      连带签名一起删

    单点登录oauth2

    restful 风格/习惯

    content-type:
      text/plain        纯文本
      application/x-www-form-urlencoded
      multipart/form-data 定界符分割各个数据

    urlencoded=>url 编码 名字=值&名字=值

    --------------------------------------------------------------------------

  3. 跨域
    1. jsonp(跨域)
      安全性问题-过于开放

    2. ajax cors跨域

    3. websocket

3. nodejs
  1. 原生nodeJS
    NodeJS和其他后台语言的不同
      优点
      1. nodejs的对象、语法和javaScript一模一样
      2. nodejs性能还可以80多倍  PHP、Java
      3. 前后台配合方便

      缺点
      1. Java极其丰富的库支持

    用处
      1. 服务器——小型后台系统、中间层
      2. 工具
        测试、构建(grunt、gulp、webpack...)、抓取

    运行NodeJS程序
      node xxx.js

    如何用nodejs搭建web服务器
      require //引入一个模块
      const http=require("http");
      let server=http.createServer((req,res)=>{
        //浏览器访问时的回调函数
        //req 请求数据
        //res 返回数据
        console.log("fjjd");//访问会执行两次 一次访问/ 一次访问/favicon.ico
        res.write(str);
        res.end();//必须否则浏览器不知道数据发送完了
      })
      server.listen(8080);

      //解析url
      const http=require("http");
      const fs=require("fs");
      let s=http.createServer((req,res)=>{
        fs.readFile(`.${req.url}`,(err,data)=>{
          if(err){
            console.log("出错");
            res.writeHeader(404);
            res.write('Not Found');
          }else{
            res.write(data);
          }
          res.end();  //这个res.end()因为异步操作事件循环的问题不能放在 1 位置
        });
      });
      //res.end()                                      1
      s.listen(8080);

    ---------------------------------------------------------------------------

    ps:
    NodeJS大量依靠模块
    常用端口:
      http:80
      mysql:3306

    NodeJS能处理并发么
      NodeJS和JS一样都是单线程、单进程
      非阻塞的异步交互  ???
      阻塞IO(c语言):前一个IO没完事，程序等着           同步
      非阻塞IO(JAVA,Node):前一个IO没完事，程序接着跑   异步

    NodeJS作中间层的好处
      安全性、性能(可以做一些缓存)、前台交互

    createServer 中回调函数的执行过程
      socket.on('data',function(){
        req=解析请求;
        res=socket;
        cb(req,res);
      })

    NodeJS三大特性
      单线程、非阻塞IO、事件循环

    负载均衡——架构师

    正向代理：内部网络对外部的访问
    反向代理：外部网络对内部的访问

    js深浅拷贝
      js对象赋值是引用形式
      浅拷贝：let arr1=arr2.concat([]);//一层
      深拷贝：let arr1=JSON.parse(JSON.stringify(arr2));

    ----------------------------------------------------------------------------

    ps:
    NodeJS模块:
      1. HTTP/HTTPS/ HTTP/2
      2. 断言
        const assert=require("assert");
        assert(条件,否时)
      3. Async Hooks (回调行为)
      4. 帮助处理二进制数——Buffer(文件/图片)
        File System
          const fs=require('fs')
          fs.readFile('path',(err,data)=>{
            //data为Buffer对象
            //二进制数据文件不要转为字符串
          });
          fs.writeFile('path','fdsfhdj',err=>{

          });
      5. C++ Addons (c++插件)
      6. 多进程(无法多线程)
        Child Processes
        Cluster
        Process
      7. Crypto——签名
        md5、sha
        const crypto=require("crypto");
        let obj=crypto.createHash('md5');
        obj.update("fjd");
        console.log(obj.digest('hex'));
      8. OS——操作系统信息
      9. Path——处理路径
      10.Events——事件队列
        async

        const EventEmitter = require('events');
        class MyEmitter extends EventEmitter {}
        const myEmitter = new MyEmitter();
        myEmitter.on('event', (a,b,c) => {
          console.log('an event occurred!');
        });
        myEmitter.emit('event',12,12,12);
      11. Query Strings
        const querystring=require('querystring');
        let obj=querystring.parse("a=12&b=13");
        console.log(obj);

        URL
          const url=require("url");
          let obj=url.parse("https://www.nuaakx.com/?a=12&b=13",true);
          console.log(obj);
      12. 网络
        TCP——稳定  Net
        UDP——快    UDP/Datagram
      13. 域名解析
        DNS
        const dns=require("dns");
        dns.resolve('baidu.com',(err,res)=>{
          if(err){
            console.log('解析失败');
          }else{
            console.log(res);
          }
        })
      14. 流操作
        连续数据都叫流——视频流、网络流、文件流、语音流
      15. TLS/SSL
        加密、安全(https基于SSL)
      16. ZLTB——gz
        压缩

    ----------------------------------------------------------------------------

    ps:
    怎么加密才最安全
      一次一密 密钥长度>内容长度
      目前最安全：RSA

    双层md5
      md5是单层散列，双层md5是散列后加混淆再散列

    多进程  成本高  慢  安全    通信麻烦  写代码简单
    多线程  成本低  快  不安全  通信简单  写代码复杂

    require:http://www.ruanyifeng.com/blog/2015/05/require.html
      任何一个js文件都是一个moudle,在被require时都会执行
      require 不是全局命令而是每个模块内部提供的方法

    程序员
      1. 算法
      2. 设计模式
      3. 架构

    网站被运营商劫持可以用https加密

    进程通信
      1. 管道
      2. 共享内存
      3. socket

    前端把加密数据传到后台，后台怎么校验
      签名

    加密算法
      RSA

    ----------------------------------------------------------------------------

    Web服务器:
      1. 返回文件
      2. 数据交互(get/post)
      3. 数据库

    大数据包要分割成一堆小

    ----------------------------------------------------------------------------









--------------------------------------------------------------------------------
